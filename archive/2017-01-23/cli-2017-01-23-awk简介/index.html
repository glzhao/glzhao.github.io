<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>awk简介 | Guangliang Zhao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="语法什么是AwkAwk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为Awk可以对文件进行操作，通常以可读文本构建行。
代码结构Awk脚本的代码结构很简单，就是一系列的模式（pattern）和行为（action）：
1234# comment">
<meta property="og:type" content="article">
<meta property="og:title" content="awk简介">
<meta property="og:url" content="http://glzhao.github.io/archive/2017-01-23/cli-2017-01-23-awk简介/index.html">
<meta property="og:site_name" content="Guangliang Zhao">
<meta property="og:description" content="语法什么是AwkAwk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为Awk可以对文件进行操作，通常以可读文本构建行。
代码结构Awk脚本的代码结构很简单，就是一系列的模式（pattern）和行为（action）：
1234# comment">
<meta property="og:updated_time" content="2017-01-23T02:37:23.233Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="awk简介">
<meta name="twitter:description" content="语法什么是AwkAwk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为Awk可以对文件进行操作，通常以可读文本构建行。
代码结构Awk脚本的代码结构很简单，就是一系列的模式（pattern）和行为（action）：
1234# comment">
  
    <link rel="alternate" href="/atom.xml" title="Guangliang Zhao" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://glzhao.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Guangliang Zhao</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">printk(KERN_DEBUG &quot;%s&quot;, &quot;I am Guangliang Zhao&quot;)</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cli-2017-01-23-awk简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archive/2017-01-23/cli-2017-01-23-awk简介/" class="article-date">
  <time datetime="2017-01-23T02:27:15.000Z" itemprop="datePublished">2017-01-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cli/">cli</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      awk简介
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="什么是Awk"><a href="#什么是Awk" class="headerlink" title="什么是Awk"></a><strong>什么是Awk</strong></h2><p>Awk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为Awk可以对文件进行操作，通常以可读文本构建行。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a><strong>代码结构</strong></h2><p>Awk脚本的代码结构很简单，就是一系列的模式（pattern）和行为（action）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># comment</span></div><div class="line">Pattern1 &#123; ACTIONS; &#125;</div><div class="line"><span class="comment"># comment</span></div><div class="line">Pattern2 &#123; ACTIONS; &#125;</div></pre></td></tr></table></figure>
<p>扫描文档的每一行时都必须与每一个模式进行匹配比较，而且一次只匹配一个模式。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><p>Awk仅有两个主要的数据类型：字符串和数字。即便如此，Awk的字符串和数字还可以相互转换。字符串能够被解释为数字并把它的值转换为数字值。如果字符串不包含数字，它就被转换为0.</p>
<p>它们都可以在你代码里的ACTIONS部分使用 = 操作符给变量赋值。我们可以在任意时刻、任意地方声明和使用变量，也可以使用未初始化的变量，此时他们的默认值是空字符串：“”。</p>
<p>最后，Awk有数组类型，并且它们是动态的一维关联数组。它们的语法是这样的：var[key] = value 。Awk可以模拟多维数组，但无论怎样，这是一个大的技巧（big hack）。</p>
<p>Awk里的变量都是全局变量。无论你在给定的块里定义什么变量，它对其他的块都是可见的，甚至是对每一行都是可见的。这严重限制了你的Awk脚本大小，不然他们会造成不可维护的可怕结果。请编写尽可能小的脚本。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a><strong>模式</strong></h2><p>可以使用的模式分为三大类：正则表达式、布尔表达式和特殊模式。</p>
<h3 id="正则表达式和布尔表达式"><a href="#正则表达式和布尔表达式" class="headerlink" title="正则表达式和布尔表达式"></a><strong>正则表达式和布尔表达式</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/admin/ &#123; ... &#125; <span class="comment"># any line that contains 'admin'</span></div><div class="line">/^admin/ &#123; ... &#125; <span class="comment"># lines that begin with 'admin'</span></div><div class="line">/admin$/ &#123; ... &#125; <span class="comment"># lines that end with 'admin'</span></div><div class="line">/^[0-9.]+ / &#123; ... &#125; <span class="comment"># lines beginning with series of numbers and periods</span></div><div class="line">/(POST|PUT|DELETE)/ <span class="comment"># lines that contain specific HTTP verbs</span></div></pre></td></tr></table></figure>
<p>注意，模式不能捕获特定的组（groups）使它们在代码的ACTIONS部分执行。模式是专门匹配内容的。</p>
<p>布尔表达式与PHP或者Javascript中的布尔表达式类似。特别的是，在awk中可以使用&amp;&amp;（“与”）、||（“或”）、!（“非”）操作符。你几乎可以在所有类C语言中找到它们的踪迹。它们可以对常规数据进行操作。</p>
<p>与PHP和Javascript更相似的特性是比较操作符，==，它会进行模糊匹配（fuzzy matching）。因此“23”字符串等于23，”23″ == 23 表达式返回true。!= 操作符同样在awk里使用，并且别忘了其他常见的操作符：&gt;，&lt;，&gt;=，和&lt;=。</p>
<p>你同样可以混合使用它们：布尔表达式可以和常规表达式一起使用。 /admin/ || debug == true 这种用法是合法的，并且在遇到包含“admin”单词的行或者debug变量等于true时该表达式就会匹配成功。</p>
<p>注意，如果你有一个特定的字符串或者变量要与正则表达式进行匹配，~ 和!~ 就是你想要的操作符。 这样使用它们：string ~ /regex/ 和 string !~ /regex/。</p>
<p>同样要注意的是，所有的模式都只是可选的。</p>
<h3 id="特殊的模式"><a href="#特殊的模式" class="headerlink" title="特殊的模式"></a><strong>特殊的模式</strong></h3><p>在Awk里有一些特殊的模式，但不是很多。</p>
<p>第一个是BEGIN，它仅在所有的行都输入到文件之前进行匹配。这是你可以初始化你的脚本变量和所有种类的状态的主要地方</p>
<p>另外一个就是END。就像你可能已经猜到的，它会在所有的输入都被处理完后进行匹配。这使你可以在退出前进行清除工作和一些最后的输出。</p>
<h2 id="行为"><a href="#行为" class="headerlink" title="行为"></a><strong>行为</strong></h2><h3 id="常用行为"><a href="#常用行为" class="headerlink" title="常用行为"></a><strong>常用行为</strong></h3><p>这里有一堆可用的行为（possible actions），但是最常用和最有用的行为（以我的经验来说）是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">print</span> <span class="variable">$0</span>; &#125; <span class="comment"># prints $0. In this case, equivalent to 'print' alone</span></div><div class="line">&#123; <span class="built_in">exit</span>; &#125; <span class="comment"># ends the program</span></div><div class="line">&#123; next; &#125; <span class="comment"># skips to the next line of input</span></div><div class="line">&#123; a=<span class="variable">$1</span>; b=<span class="variable">$0</span> &#125; <span class="comment"># variable assignment</span></div><div class="line">&#123; c[<span class="variable">$1</span>] = <span class="variable">$2</span> &#125; <span class="comment"># variable assignment (array)</span></div><div class="line"></div><div class="line">&#123; </div><div class="line">        <span class="keyword">if</span> (BOOLEAN) &#123; ACTION &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (BOOLEAN) &#123; ACTION &#125;</div><div class="line">        <span class="keyword">else</span> &#123; ACTION &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123; <span class="keyword">for</span> (i=1; i&lt;x; i++) &#123; ACTION &#125; &#125;</div><div class="line">&#123; <span class="keyword">for</span> (item <span class="keyword">in</span> c) &#123; ACTION &#125; &#125;</div></pre></td></tr></table></figure>
<h3 id="print和printf"><a href="#print和printf" class="headerlink" title="print和printf"></a><strong>print和printf</strong></h3><p>awk中同时提供了print和printf两种打印输出的函数。其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。</p>
<p>printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><p>可以使用下面的语法来调用函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; somecall($2) &#125;</div></pre></td></tr></table></figure>
<p>用户定义的函数同样很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># function arguments are call-by-value</div><div class="line">function name(parameter-list) &#123;</div><div class="line">        ACTIONS; # same actions as usual</div><div class="line">&#125;</div><div class="line"></div><div class="line"># return is a valid keyword</div><div class="line">function add1(val) &#123;</div><div class="line">        return val+1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a><strong>特殊变量</strong></h3><p>除了常规变量（全局的，可以在任意地方使用），这里还有一系列特殊的变量，它们的的作用有点像配置条目（configuration entries）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ARGC               命令行参数个数</div><div class="line">ARGV               命令行参数排列</div><div class="line">ENVIRON            支持队列中系统环境变量的使用</div><div class="line">FILENAME           awk浏览的文件名</div><div class="line">FNR                浏览文件的记录数</div><div class="line">FS                 设置输入域分隔符，等价于命令行 -F选项</div><div class="line">NF                 浏览记录的域的个数</div><div class="line">NR                 已读的记录数</div><div class="line">OFS                输出域分隔符</div><div class="line">ORS                输出记录分隔符</div><div class="line">RS                 控制记录分隔符</div></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h1><h2 id="处理erlang-crash-dump"><a href="#处理erlang-crash-dump" class="headerlink" title="处理erlang crash dump"></a><strong>处理erlang crash dump</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Parse Erlang Crash Dumps and correlate mailbox size to the currently running</span></div><div class="line"><span class="comment"># function.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Once in the procs section of the dump, all processes are displayed with</span></div><div class="line"><span class="comment"># =proc:&lt;0.M.N&gt; followed by a list of their attributes, which include the</span></div><div class="line"><span class="comment"># message queue length and the program counter (what code is currently</span></div><div class="line"><span class="comment"># executing).</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Run as:</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># $ awk -v threshold=$THRESHOLD -f queue_fun.awk $CRASHDUMP</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Where $THRESHOLD is the smallest mailbox you want inspects. Default value</span></div><div class="line"><span class="comment"># is 1000.</span></div><div class="line">BEGIN &#123;</div><div class="line"><span class="keyword">if</span> (threshold == <span class="string">""</span>) &#123;</div><div class="line">threshold = 1000 <span class="comment"># default mailbox size</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">procs = 0 <span class="comment"># are we in the =procs entries?</span></div><div class="line"><span class="built_in">print</span> <span class="string">"MESSAGE QUEUE LENGTH: CURRENT FUNCTION"</span></div><div class="line"><span class="built_in">print</span> <span class="string">"======================================"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Only bother with the =proc: entries. Anything else is useless.</span></div><div class="line">procs == 0 &amp;&amp; /^=proc/ &#123; procs = 1 &#125; <span class="comment"># entering the =procs entries</span></div><div class="line">procs == 1 &amp;&amp; /^=/ &amp;&amp; !/^=proc/ &#123; <span class="built_in">exit</span> 0 &#125; <span class="comment"># we're done</span></div><div class="line"></div><div class="line"><span class="comment"># Message queue length: 1210</span></div><div class="line"><span class="comment"># 1 2 3 4</span></div><div class="line">/^Message queue length: / &amp;&amp; <span class="variable">$4</span> &gt;= threshold &#123; flag=1; ct=<span class="variable">$4</span> &#125;</div><div class="line">/^Message queue length: / &amp;&amp; <span class="variable">$4</span> &lt; threshold &#123; flag=0 &#125;</div><div class="line"></div><div class="line"><span class="comment"># Program counter: 0x00007f5fb8cb2238 (io:wait_io_mon_reply/2 + 56)</span></div><div class="line"><span class="comment"># 1 2 3 4 5 6</span></div><div class="line">flag == 1 &amp;&amp; /^Program counter: / &#123; <span class="built_in">print</span> ct <span class="string">":"</span>, substr(<span class="variable">$4</span>,2) &#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://glzhao.github.io/archive/2017-01-23/cli-2017-01-23-awk简介/" data-id="ciy9k9ofm0006q4jxiqc26ucf" class="article-share-link">分享</a>
      
      
        <a href="http://glzhao.github.io/archive/2017-01-23/cli-2017-01-23-awk简介/#disqus_thread" class="article-comment-link">留言</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/awk/">awk</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/archive/2017-01-23/cli-2017-01-23-bash组合命令/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          bash组合命令
        
      </div>
    </a>
  
  
    <a href="/archive/2017-01-22/others-2017-01-22-迁移blog到hexo/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">迁移blog到hexo</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#语法"><span class="toc-number">1.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Awk"><span class="toc-number">1.1.</span> <span class="toc-text">什么是Awk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码结构"><span class="toc-number">1.2.</span> <span class="toc-text">代码结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式"><span class="toc-number">1.4.</span> <span class="toc-text">模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式和布尔表达式"><span class="toc-number">1.4.1.</span> <span class="toc-text">正则表达式和布尔表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊的模式"><span class="toc-number">1.4.2.</span> <span class="toc-text">特殊的模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行为"><span class="toc-number">1.5.</span> <span class="toc-text">行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用行为"><span class="toc-number">1.5.1.</span> <span class="toc-text">常用行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#print和printf"><span class="toc-number">1.5.2.</span> <span class="toc-text">print和printf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-number">1.5.3.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊变量"><span class="toc-number">1.5.4.</span> <span class="toc-text">特殊变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#示例"><span class="toc-number">2.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#处理erlang-crash-dump"><span class="toc-number">2.1.</span> <span class="toc-text">处理erlang crash dump</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 Guangliang Zhao&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;lucienchao@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
    
<script>
  var disqus_shortname = 'glzhao';
  
  var disqus_url = 'http://glzhao.github.io/archive/2017-01-23/cli-2017-01-23-awk简介/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>